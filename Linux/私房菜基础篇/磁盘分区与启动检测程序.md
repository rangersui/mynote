

[toc]

# 磁盘分区

虚拟化是目前常见的一项技术。在虚拟机的情况下，虚拟磁盘并不是正规磁盘接口。一般物理机名字为/dev/sd[a-p]的磁盘文件名，虚拟机中为了加速，可能会使用/dev/vd[a-p]这种设备文件名。

## 设备对应的Linux文件名称

| 设备                    | 设备在Linux中的文件名                                        |
| ----------------------- | ------------------------------------------------------------ |
| SCSI,SATA,USB磁盘驱动器 | /dev/sd[a-p]                                                 |
| U盘                     | /dev/sd[a-p] (与sata相同)                                    |
| Virtio接口              | /dev/vd[a-p]                                                 |
| 软盘驱动器              | /dev/lp[0-7]                                                 |
| 打印机                  | /dev/lp[0-2] (25针打印机)  /dev/usb/lp[0-15]  (USB接口)      |
| 鼠标                    | /dev/input/mouse[0-15] (通用)  /dev/psaux (PS/2接口)  /dev/mouse  (当前鼠标) |
| CD-ROM、DVD-ROM         | /dev/scd[0-1] (通用)  /dev/sr[0-1] (通用，CentOS常见)  /dev/cdrom  (当前CD-ROM) |
| 磁带机                  | /dev/ht0 (IDE接口)  /dev/st0 (SATA/SCSI接口)  /dev/tape (当前磁带) |
| IDE磁盘驱动器           | /dev/hd[a-d]  （旧式系统）                                   |

目前IDE接口的磁盘驱动器会被模拟为/dev/sd[a-p]。此外，云端机器一般是虚拟机，虚拟机内的磁盘名一般为/dev/vd[a-p]

可以通过以下方式查看

```bash
cd /dev/
ls | grep sda
```



### virtio接口

虚拟化环境必须使用客户操作系统自身的驱动感觉不到自己运行在虚拟机上，不然让客户操作系统开发人员编写大量代码同样不是一个很好的设计方案，因此虚拟化系统需要提供抽象设备，抽象设备实现了针对特定设备类的高级接口，目前比较高效的设备虚拟化接口是Virtio

## MBR(MS-DOS)与GPT磁盘分区表

早期磁盘第一个扇区包含有重要信息，称为MBR（Master Boot Record，主引导记录）格式，但是由于近年来磁盘的容量不断扩大，造成读写上的困扰，甚至有些2TB以上的磁盘分区已经让某些操作系统无法存取，因此后来又多了一个新的磁盘分区格式，称为GPT（GUID partition table，全局唯一标识符分区表），这两种分区格式与限制不太相同。

### MBR（MS-DOS）

启动引导程序记录区与分区表则统统放在磁盘的第一个扇区，这个扇区通常是512字节的大小，所以说第一个扇区主要记录以下两个东西：

- 主引导记录（Master Boot Record，MBR）：可以安装启动引导程序,446字节；

- 分区表（partition table）：记录整块硬盘分区的状态，有64字节；

  由于分区表所在区块仅有64字节容量，因此只能有**四组记录区**，每组记录区记录了该区段的**起始与结束的柱面号码**。假设硬盘设备文件名为/dev/sda时，那么四个分区会在文件名后多加一个数字：

  - P1:/dev/sda1
  - P2:/dev/sda2
  - P3:/dev/sda3
  - P4:/dev/sda4

由于分区只有64字节，**最多能容纳四组分区记录**，这四个分区的记录被称为主要或扩展分区。有以下几点：

- 分区是针对64字节的分区表进行设置
- 默认的分区表只能写入四组分区信息
- 这四组分区信息称为主要/扩展分区
- 分区最小单位通常为柱面
- 系统写入磁盘时，一定要考虑分区表，才能针对某个分区进行数据处理。

那是不是一块磁盘只能分四个分区呢？当然不是。在Linux和Windows中，我们通过**扩展分区**的方式进行处理。扩展分区使用额外的扇区记录分区信息，扩展分区本身并不能被拿来作为格式化。

**由扩展分区划分出来的分区**被称为**逻辑分区**，由于逻辑分区由扩展分区继续划分出来的，所以它可以使用柱面范围和扩展分区的范围一致。**逻辑分区的设备名称号码由5号开始**

MBR主要分区、扩展分区与逻辑分区的特性有以下定义：

- 主要分区与扩展分区（硬盘的限制）

- 扩展分区最多只能有1个（操作系统的限制）

- 逻辑分区是由扩展分区持续划分出来的分区

- 能够被格式化后作为数据存储的分区时主要分区与逻辑分区，扩展分区无法格式化

- 逻辑分区的数量依赖操作系统而不同，在Linux系统中SATA硬盘以及可以突破63个以上的分区限制

- 同一个扩展分区的两个逻辑分区可以合并，主分区和逻辑分区不可以合并。

  - P+P+P+E为例，分区编号为/dev/sdb[1-3] [4] [5-7]其中sdb4这个扩展分区不可用，仅作为建立逻辑分区使用。

  - P+E为例，分区编号为/dev/sdb[1] [2] [5-9] 其中sdb2为扩展分区

- MBR仅有一个区块，被破坏后很难恢复
- MBR内的存放启动引导程序的区块仅446字节，无法储存较多的程序代码

## GPT磁盘分区表

过去一个扇区的大小为512字节，目前已经有4k的扇区设计出现，因此为了兼容所有磁盘，扇区的定义上面大多使用**逻辑区块地址**（Logical Block Address，LBA）来处理。GPT将磁盘所有区块以此LBA（默认为512字节）来规划，第一个LBA称为LBA0.

GPT采用34个LBA区块记录分区信息，除了前面34个区块之外，整个磁盘的最后34个LBA也拿来作为另一个备份。

- LBA0（MBR兼容区块）

  与MBR模式相似，这个兼容区块分为两个部分，一个是和MBR一样的446字节区块，储存第一阶段的启动引导程序。而在原本的分区表记录区内，这个兼容模式仅放入一个特殊标识符代表为GPT格式。不兼容GPT分区表的磁盘管理程序不会识别该磁盘，除非用户特别要求处理该磁盘，否则管理软件不能修改此分区信息。

- LBA1（GPT表头记录）

  记录了分区表本身的位置和大小，同时记录类备份用的GPT分区（最后34个区块）放置了分区表的校验码（CRC32），操作系统根据这个校验码判断GPT是否正确。若有错误，还可以该记录区获取备份的GPT恢复。

- LBA2-33（实际记录分区信息处）

  从LBA2区块开始，每个LBA可以记录4组分区记录，默认情况下可以有4*32=128组。每个LBA有512字节，**每组记录使用128字节**，除了每组记录所需要的标识符与相关的记录之外，GPT在每组记录区中分别提供了64位来记载开始/结束的扇区号码。因此每个分区最大容量限制为2\^64\*512字节，等于2\^33TB

GPT分区没有主、扩展和逻辑分区的概念，既然每组记录都可以独立存在，当然每个都可以视为主要分区，每个分区都可以格式化。

磁盘工具上，fdisk不支持GPT，需要gdisk或者parted命令。启动引导程序方面，grub第一版不支持GPT，需要grub2以后的版本。能否读取GPT也与**启动的检测程序**有关。

# 启动检测程序BIOS与UEFI

目前主机系统在加载硬件驱动方面的程序，主要有早期的BIOS与新的UEFI两种机制。

## BIOS搭配MBR/GPT启动

BIOS是在启动的时候，计算机会主动执行的第一个程序。接下来BIOS会分析计算机里面的存储设备（例如硬盘）然后从硬盘中读取第一个扇区的MBR位置，其中的446字节的启动引导程序。启动引导程序会开始工作，目的是加载内核文件。

- BIOS：启动主动执行的固件（指设备内部保存的设备“驱动程序”），会认识第一个可启动的设备
- MBR：第一个可启动设备的第一个扇区内的主引导记录快，内含启动引导代码
- 启动引导程序（Boot loader）：一个可读取内核文件来执行的软件
- 内核文件：启动操作系统

对于GPT而言，BIOS同样可以通过LBA0的MBR兼容区块读取第一阶段的启动引导程序代码，如果启动引导程序能够支持GPT，那么使用BIOS同样可以读取到操作系统内核。若启动引导程序不支持GPT，例如Windows XP，则无法读取内核文件，不能启动操作系统。

BIOS与MBR都是硬件本身支持的功能，至于Boot loader则是操作系统安装在MBR上的软件。Bootloader提供以下功能：

- 提供选项：用户选择不同的启动选项，这也是多重引导的重要功能
- 加载内核文件：直接指向可使用的程序区段来启动操作系统
- 转交其他启动引导程序：将启动管理功能转交给其他启动引导程序负责

启动引导程序除了可以安装在MBR以外，还可以安装在每个分区的启动扇区（Boot sector）。第三个功能实现了多重引导的功能。

linux在安装的时候，你可以选择将启动引导程序安装在MBR或者其他分区的启动扇区，而linux可以手动选择，因此可以在启动引导程序中加入windows启动的选项；

windows安装的时候会主动覆盖MBR以及自己所在分区的启动扇区。可以通过Linux的恢复模式来修复。

## UEFI BIOS搭配GPT启动

为了解决16位BIOS程序与新操作系统接轨方面的问题，UEFI（Unified extensible Firmware Interface）这个统一可扩展固件接口诞生了。

UEFI主要是想取代BIOS这一固件接口，因此UEFI也被称为UEFI BIOS。使用C语言编写，比传统汇编开发的BIOS更容易开发。

| 比较项目             | 传统BIOS                                            | UEFI BIOS          |
| -------------------- | --------------------------------------------------- | ------------------ |
| 实用程序语言         | 汇编语言                                            | C语言              |
| 硬件资源控制         | 使用中断（IRQ）管理 不可变的内存存取、输入/输出存取 | 使用驱动程序与协议 |
| 处理器运行环境       | 16位                                                | CPU保护模式        |
| 扩充方式             | 通过IRQ连接                                         | 直接加载驱动程序   |
| 第三方厂商支持       | 较差                                                | 较佳且可支持多平台 |
| 图形能力             | 较差                                                | 较佳               |
| 内置简化操作系统环境 | 不支持                                              | 支持               |

UEFI接近一个低级的操作系统，硬件资源采用轮询（Polling）方式管理。UEFI不提供完整的缓存功能，因此执行效率没有办法提升。加载所用的UEFI驱动程序之后会启动一个类似操作系统Shell环境，用户可以在此环境中执行任意的UEFI应用程序，而且效果会被MS-DOS好。

UEFI有一个安全启动功能（secure boot），这个功能代表着即将启动的操作系统必须要被UEFI所验证，Linux可能因此无法启动。虽然UEFI可以直接获取GPT分区表，但是最好依旧拥有BIOS boot的分区支持，为了与Windows兼容，并且提供其他第三方厂商所使用的UEFI应用程序储存的空间，必须格式化一个FAT格式的文件系统分区，提供512MB到1GB左右的大小，以让其他UEFI执行较为方便。

### 驱动（Driver）和固件（Firmware）

在Linux Kernel中，Driver和Firmware是有明确含义的，其中Driver是控制被操作系统管理的外部设备（Device）的代码段。很多时候Driver会被实现为LKM（可加载内核模块），但这不是必要条件。

driver通过driver_register()注册到总线(bus_type）上，代表系统具备了驱动某种设备（device）的能力。当某个device被注册到同样的总线的时候（通常是总线枚举的时候发现了这个设备），总线驱动会对driver和device会通过一定的策略进行binding（即进行匹配），如果Binding成功，总线驱动会调用driver的probe()函数，把设备的信息（例如端口，中断号等）传递给驱动，驱动就可以对真实的物理部件进行初始化，并把对该设备的控制接口注册到Linux的其他子系统上（例如字符设备，v4l2子系统等）。这样操作系统的其他部分就可以通过这些通用的接口来访问设备了。

而Firmware，是表示运行在非“控制处理器”（指不直接运行操作系统的处理器，例如外设中的处理器，或者被用于bare metal的主处理器的其中一些核）中的程序。这些程序很多时候使用和操作系统所运行的处理器完全不同的指令集。这些程序以二进制形式存在于Linux内核的源代码树中，生成目标系统的时候，通常拷贝在/lib/firmware目录下。当driver对device进行初始化的时候，通过request_firmware()等接口，在一个用户态helper程序的帮助下，可以把指定的firmware加载到内存中，由驱动传输到指定的设备上。

所以，总的来说，其实driver和firmware没有什么直接的关系，但firmware通常由驱动去加载。我们讨论的那个OS，一般不需要理解firmware是什么，只是把它当做数据。firmware是什么，只有使用这些数据的那个设备才知道。好比你用一个电话，电话中有一个软件，这个软件你完全不关心如何工作的，你换这个软件的时候，就可以叫这个软件是“固件”，但如果你用了一个智能手机，你要细细关系什么是上面的应用程序，Android平台，插件之类的细节内容，你可能就不叫这个东西叫“固件”了。

参考：[驱动与固件的区别是什么？](https://www.zhihu.com/question/22175660/answer/27278490)