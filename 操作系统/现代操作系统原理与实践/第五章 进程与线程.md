[toc]

# 进程

## 进程有哪些状态？为什么要定义这些状态？

- 新生状态（new）

  一个进程刚刚被创建，**还没有完成初始化，不能被调度执行**，完成初始化转移到就绪状态。

- 就绪状态（ready）

  进程**可以被调度执行，还未被调度器选择**。CPU数量少于进程数量，在某一时刻只能部分进程被调度到CPU上执行。此时，系统中其他可被调度的进程都处于就绪状态。在被调度器选择执行后，进程迁移至运行状态。

- 运行状态（running）

  正在CPU上运行，**执行一段时间后，调度器可以选择中断它并重新将其放入调度队列**，迁移至就绪状态。当程序运行结束，迁移至终止状态。如果一个进程需要等待某些外部状态，可以放弃CPU并迁移至阻塞状态。

- 阻塞状态（blocked）

  进程需要**等待外部事件，暂时无法被调度**。等待的外部事件完成后，迁移至就绪状态。

- 终止状态（terminated）

  进程已经完成了执行，**不会再被调度**。

## 进程的虚拟地址空间是什么样的结构？

- 用户栈

  保存了进程需要使用的**各种临时数据**（如临时变量）。栈是一种可以伸缩的数据结构，扩展方向为**自顶向下**。

- 代码库

  进程的执行需要依赖**共享的代码库**如libc，这些代码库会被映射到用户栈下方的虚拟地址处并标记**只读**。

- 用户堆

  进程**动态分配的内存**，**自底向上**。

- 数据与代码段

  原本都保存在进程需要执行的二进制文件中，在进程执行前，操作系统会将他们载入虚拟地址空间中，数据段主要保存**全局变量值**，代码段保存**进程执行所需的代码**。

- 内核部分

  进程空间**最顶端的是内核内存**，每个进程的虚拟地址空间**都映射了相同的内核内存**，当进程在**用户态运行时不可见**，进入**内核态可访问**。

  内核部分也有内核需要的代码和数据段，进程由于中断或系统调用进入内核后，会使用内核的栈。

> Linux中，用户可以通过cat /proc/PID/maps来查看某个进程的内存空间布局。由于内核地址空间对用户态不可见，maps没有包含内核部分映射。vdso和vvar是与系统调用相关的内存区域。进程还会映射一些匿名的内存区域用于完成缓存，共享内存的操作。

## 进程是如何进行上下文切换的？

每个进程通过一个数据结构保存相关状态，如PID，进程状态，虚拟内存状态，打开的文件等。该数据结构称为**进程控制块PCB**，不同操作系统的PCB内容可能有所不同。

上下文包括进程运行时的寄存器状态，能够用于保存和回复一个进程在处理器上的运行的状态。当该操作系统需要切换当前执行的进程时，就会使用上下文切换机制。该机制会**将前一个进程的寄存器状态保存到PCB中**，然后将**下一个进程先前保存的状态写入寄存器**从而切换到该进程执行。

> 早期操作系统中，进程是操作系统调度的基本单位。但随着更加轻量级的运行时抽象——线程的提出，调度和上下文切换的基本单位也由进程变为线程。

# Linux进程操作

## 为什么Linux要采取fork的方式创建进程？

[Why do we need to fork to create new processes?](https://unix.stackexchange.com/questions/136637/why-do-we-need-to-fork-to-create-new-processes)

[Linux 写时复制机制原理](https://zhuanlan.zhihu.com/p/366707663)

直接创建进程相比fork方式创建进程没那么有效率：

- fork函数的copy过程是比较抽象的，因为内核采用写时拷贝机制，它所需要做的就是创建一个虚拟内存的映射。如果在拷贝之后立刻调用exec函数，则当子进程对虚拟页进行写操作时，触发缺页异常，复制一份新的物理内存页并将子进程虚拟内存页映射到新物理内存页，同时将父子进程的虚拟内存页设置为可读写。
- 子进程有很多重要的信息（如环境）不需要单独复制或根据上下文的复杂分析来设置。他们被假定为与调用的进程相同。

简单来说写时拷贝机制使得子进程得以复用父进程的内存页**减少了重复数据，创建子进程更快捷**。

## 为什么需要写时拷贝技术？

早期fork会完整拷贝父进程的物理内存，并映射到子进程的内存空间中。通过写时拷贝技术优化后，原本只是只读的虚拟页（如代码段）来说，父进程和子进程能直接共享这些项，**减少拷贝开销**，既能提升fork性能，又能**降低进程占用的内存资源**。

## fork和其他创建进程的方法相比有什么优点和缺点？

### 优点

- fork不需要参数，由于fork生成的子进程来自于父进程的拷贝，实现简单。

- fork和exec的组合可以认为是**将进程创建过程进一步解耦**，程序可以在fork调用后，exec调用前对子进程进行各种设定，比如文件重定向。
- fork强调了进程与进程之间的联系，由于fork具有创建原有进程的拷贝的语义，原进程与fork创建的进程之间存在比较强的联系，**为进程管理提供了便利**。

### 缺点

- fork变得过于复杂，当操作系统为进程提供新功能时，必须考虑到对fork的实现和修改，需要应对的特殊情况越来越多，代码越来越复杂。另外，fork的实现与进程、内存管理等模块的耦合度太高，不利于内核代码维护。
- 性能太差，需要创建原进程的拷贝，原进程状态越多，fork性能越差。
- 存在安全漏洞，BROP（Blind Return Oriented Programming）攻击利用了fork父进程和子进程之间的联系，BROP多次向Web服务器发起请求，促使服务器调用fork创建每次都相同的地址空间和内存数据，通过反复尝试（千次请求，几分钟左右）完成攻击。
- 扩展性差
- 与异质硬件不兼容
- 线程不安全

## 进程树是如何方便操作系统进行管理的？

通过进程树结构，内核为进程建立了联系并在此基础上提供了**监控，回收，信号分发**等一系列功能。

# 线程

## 为什么需要引入线程？

- **创建进程开销较大**，需要完成创建独立的地址空间、载入数据和代码段、初始化堆等步骤。使用fork将会对父进程进行大量拷贝。
- 进程拥有独立的虚拟地址空间，在进程间需要进行**数据共享和同步比较麻烦**，一般只能基于共享虚拟页（粒度较粗）或基于进程间通信（开销高）。

通过在进程内部添加课独立执行的单元，他们共享进程的地址空间，但又各自保存运行时所需的状态（上下文），这就是线程，现在线程已经成为了操作系统调度和管理程序的最小单元。

## 拥有多个线程的进程的虚拟地址空间结构是什么样的？

- 分离的内核栈与用户栈

  每个线程的执行相对独立，进程为每个线程准备了不同的栈。在内核中不同线程也有对应的内核栈。

- 共享的其他区域

  进程除了栈以外的其他区域段都由所有线程共享，包括堆、数据段、代码段等。同一进程的多个线程需要动态分配更多内存时，内存分配操作都在同一个堆上完成。

## 用户态线程与内核态线程的区别和联系分别是什么？

内核态线程由内核态创建受操作系统调度器直接管理，用户态线程由应用自己创建，内核不可见，因此也不直接受系统调度器管理。

用户态线程比内核态线程更加轻量级，创建开销更小，功能较为受限，需要内核态线程协助完成内核态相关操作。

为了实现用户态线程与内核态线程的协作，有两类线程的**多线程模型**：

- 多对一

  多个用户态线程映射给单一的内核态线程。模型简单，**每次只能有一个用户态线程可以进入内核，其他用户态线程会被阻塞**。

- 一对一

  **为每个用户态线程映射单独的内核态线程**。相比于多对一模型，一对一模型提供了更好的可扩展性，但是内核态线程的**开销随着用户态线程数量的增加而增加**。所以往往对用户态线程的总数量进行限制。

- 多对多

  N个用户态线程映射到M个内核态线程，其中N>M。比如多核机器中，可以将内核态现成的数量M设定为核心数，而用户态线程的数量不做限制。**解决了内核态线程太少导致的阻塞，页解决了内核态线程过多造成的性能开销过大**，但是让**内核态线程管理变得复杂**。

## 针对线程的核心操作有哪些？

以POSIX线程库为例

### 线程创建

通过clone实现pthread_create。

### 线程退出

pthreads提供了pthread_exit，调用并不是必要的。当一个线程的主函数执行结束时，pthread_exit将会隐式地被调用。

### 出让资源

主动暂停，让出当前CPU，交给其他线程使用，接口为pthread_yield。此时线程还是**就绪状态**。

比如当一个程序需要等待外部事件时，此时对它的调度没有实际意义，通过pthread_yield告诉调度器，自己不需要被调度，可以把资源分配给其他线程。

### 合并操作

可能会出现线程互相依赖的情况，线程库提供合并操作，允许一个线程**等待另一个线程的执行，并获取执行结果**。

比如当一个主线程创建了很多工作线程之后，可以通过调用合并操作**获取各工作线程的返回值**，判断执行是否出错。pthreads提供了pthread_join函数来支持合并操作。

### 挂起与唤醒

当线程发现自己的执行需要等待外部事件时，可以**进入阻塞状态**。提供了两种方式：固定时间和等待具体事件。

#### sleep

挂起数秒，也提供细粒度更高的nanosleep控制挂起纳秒。当sleep被调用，会将对应线程状态设为阻塞，在时间走完后唤醒。但内核不能保证被唤醒后立刻被调度。

#### pthread_cond_wait

使用**条件变量**作为同步方式，会使线程等待cond，内核挂起该线程，当其他线程使用pthread_cond_signal操作同一个条件变量cond时，内核会协助将挂起的线程唤醒，使其进入就绪状态。

### 出让和挂起

yield使用后，线程将继续处于就绪状态，并可能很快就会被调度，甚至在没有其他可调度的线程情况下，该线程甚至会继续执行。而线程调度sleep之后会进入阻塞状态，只有条件满足才会恢复到就绪。

yield适合很快会被再次调用的场景，sleep适合等待条件被满足时间不确定或较长的情况下。

# ChCore线程上下文

## 线程上下文与TCB

线程上下文是上下文切换的基础。为了实现不同不同进程间切换，需要保存处理器运行一个线程时的所有状态信息，这些状态信息就是线程上下文，包括：

- 程序计数器，当前执行指令的地址
- 通用寄存器，当前处理数据
- 特殊寄存器，硬件状态和配置如页表地址等

# 纤程（协程）

## 为什么对纤程的需求越来越强烈？

应用程序对线程的语义和执行状态更加了解，因此可能做出更优的调度策略。此外，用户态线程更加轻量级，更多地使用用户态线程有利于提高整个系统的可扩展性，操作系统开始提供更多对用户态线程即纤程支持，用户态与内核态线程的关系也由一对一向多对一发展。

## 什么是纤程？如何使用纤程？

以POSIX的线程支持为例，有代码如下：

```c
#include <signal.h>
#include <stdio.h>
#include <ucontext.h>
#include <unistd.h>

ucontext_t ucontext1, ucontext2;

int current = 0;

void produce()
{
        current++;
        setcontext(&ucontext2);
}

void consume()
{
        printf("current value: %d\n", current);
        setcontext(&ucontext1);
}

int main(int argc, const char *argv[])
{
        char func_stack1[SIGSTKSZ];
        char func_stack2[SIGSTKSZ];

        getcontext(&ucontext1);
        ucontext1.uc_link          = NULL;
        ucontext1.uc_stack.ss_sp   = func_stack1;
        ucontext1.uc_stack.ss_size = sizeof(func_stack1);
        makecontext(&ucontext1, (void (*) (void))produce, 0);

        getcontext(&ucontext2);
        ucontext2.uc_link          = NULL;
        ucontext2.uc_stack.ss_sp   = func_stack2;
        ucontext2.uc_stack.ss_size = sizeof(func_stack2);
        makecontext(&ucontext2, (void (*) (void))consume, 0);

        setcontext(&ucontext1);

        return 0;
}
```

通过makecontext创建两个上下文ucontext1和ucontext2，分别用于调用produce和consume两个函数。

使用纤程，可以对生产消费者这类需要多个模块协作的场景进行有效支持。生产者完成任务后可以立即切换到消费者继续执行，由于该切换通过用户态线程库完成，不需要操作系统参与，不受调度器控制，可以达到很好的性能。

## 纤程如何进行上下文切换？

纤程不具备使用中断抢占其他纤程的权限，无法使用抢占式多任务处理，所以纤程库提供yield接口，使得暂时放弃CPU允许其他纤程的调用。该调度方式被称为合作式多任务处理，需要多个纤程进行协作以完成调度。在ucontext中，setcontext提供了与yield类似的功能。

setcontext在用户态完成切换，不涉及内核态和用户态之间的切换，也不涉及对上一个上下文的保存，性能明显优于线程的上下文切换。

## 纤程与进程、线程的区别有哪些？

**coroutine** live in a thread, a **thread** lives in process, a **process** lives in core, a **core** lives in a CPU.

- 多进程通常是指多个进程**并行**执行。进程是**最小的资源管理单元**，不同的进程共享不同的资源。
- 多线程通常是指多个线程**并发**执行，当有空闲内核时，线程可以使用空闲内核**并行**运行。线程是**最小的执行单元**，一个程序至少需要一个线程才能运行。
- 协程通常是指许多例程**并发**执行。

协程在线程中并发运行，就像线程在进程中并发运行一样，但是：

- 并发执行需要上下文切换，协程的上下文切换比多线程更快
- 协程由用户管理，多线程由内核管理。开发者可以通过使用协程更好地控制执行流程，例如不会强制协程让步（yield）。
- 协程不能并行运行。

并发和并行：

- 并发：线程A和线程B在同一个进程中，轮流拥有进程，在等待资源或预定cpu时间用完时yield。

- 并行：线程A和线程B在不同的进程中，同时执行。

# 思考题

应该需要看完第八章同步原语才能作答？

留一点可能的参考文献：

[Threads and fork(): think twice before mixing them.](https://www.linuxprogrammingblog.com/threads-and-fork-think-twice-before-using-them)

[谨慎使用多线程中的fork](https://www.cnblogs.com/liyuan989/p/4279210.html)

[Forking vs Threading](https://stackoverflow.com/questions/16354460/forking-vs-threading)

## 为什么不用类似于fork的方法创建线程呢？



## Linux中，一个多线程进程使用fork生成了一个新进程，新进程中会存在几个线程？为什么要这么设计?



## 编写至少两种使用fork的程序，使fork执行失败，解释fork失败的原因。



## 为什么ChCore能保证内核态线程的栈进入/退出内核时一定是空的？

