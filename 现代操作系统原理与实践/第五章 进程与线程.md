[toc]

# 进程

## 进程有哪些状态？为什么要定义这些状态？

- 新生状态（new）

  一个进程刚刚被创建，**还没有完成初始化，不能被调度执行**，完成初始化转移到就绪状态。

- 就绪状态（ready）

  进程**可以被调度执行，还未被调度器选择**。CPU数量少于进程数量，在某一时刻只能部分进程被调度到CPU上执行。此时，系统中其他可被调度的进程都处于就绪状态。在被调度器选择执行后，进程迁移至运行状态。

- 运行状态（running）

  正在CPU上运行，**执行一段时间后，调度器可以选择中断它并重新将其放入调度队列**，迁移至就绪状态。当程序运行结束，迁移至终止状态。如果一个进程需要等待某些外部状态，可以放弃CPU并迁移至阻塞状态。

- 阻塞状态（blocked）

  进程需要**等待外部事件，暂时无法被调度**。等待的外部事件完成后，迁移至就绪状态。

- 终止状态（terminated）

  进程已经完成了执行，**不会再被调度**。

## 进程的虚拟地址空间是什么样的结构？

- 用户栈

  保存了进程需要使用的**各种临时数据**（如临时变量）。栈是一种可以伸缩的数据结构，扩展方向为**自顶向下**。

- 代码库

  进程的执行需要依赖**共享的代码库**如libc，这些代码库会被映射到用户栈下方的虚拟地址处并标记**只读**。

- 用户堆

  进程**动态分配的内存**，**自底向上**。

- 数据与代码段

  原本都保存在进程需要执行的二进制文件中，在进程执行前，操作系统会将他们载入虚拟地址空间中，数据段主要保存**全局变量值**，代码段保存**进程执行所需的代码**。

- 内核部分

  进程空间**最顶端的是内核内存**，每个进程的虚拟地址空间**都映射了相同的内核内存**，当进程在**用户态运行时不可见**，进入**内核态可访问**。

  内核部分也有内核需要的代码和数据段，进程由于中断或系统调用进入内核后，会使用内核的栈。

> Linux中，用户可以通过cat /proc/PID/maps来查看某个进程的内存空间布局。由于内核地址空间对用户态不可见，maps没有包含内核部分映射。vdso和vvar是与系统调用相关的内存区域。进程还会映射一些匿名的内存区域用于完成缓存，共享内存的操作。

## 进程是如何进行上下文切换的？

每个进程通过一个数据结构保存相关状态，如PID，进程状态，虚拟内存状态，打开的文件等。该数据结构称为**进程控制块PCB**，不同操作系统的PCB内容可能有所不同。

上下文包括进程运行时的寄存器状态，能够用于保存和回复一个进程在处理器上的运行的状态。当该操作系统需要切换当前执行的进程时，就会使用上下文切换机制。该机制会**将前一个进程的寄存器状态保存到PCB中**，然后将**下一个进程先前保存的状态写入寄存器**从而切换到该进程执行。

> 早期操作系统中，进程是操作系统调度的基本单位。但随着更加轻量级的运行时抽象——线程的提出，调度和上下文切换的基本单位也由进程变为线程。

# Linux进程操作

## 为什么Linux要采取fork的方式创建进程？

[Why do we need to fork to create new processes?](https://unix.stackexchange.com/questions/136637/why-do-we-need-to-fork-to-create-new-processes)



## 为什么需要写时拷贝技术？



## fork和其他创建进程的方法相比有什么优点和缺点？



## 进程树是如何方便操作系统进行管理的？



# 线程

## 为什么需要引入线程？



## 拥有多个线程的进程的虚拟地址空间结构是什么样的？



## 用户态线程与内核态线程的区别和联系分别是什么？



## 针对线程的核心操作有哪些？



# 纤程

## 为什么对纤程的需求越来越强烈？



## 什么是纤程？如何使用纤程？



## 纤程如何进行上下文切换？



## 纤程与进程、线程的区别有哪些？



# 思考题

## 为什么不用类似于fork的方法创建线程呢？



## Linux中，一个多线程进程使用fork生成了一个新进程，新进程中会存在几个线程？为什么要这么设计?



## 编写至少两种使用fork的程序，使fork执行失败，解释fork失败的原因。



## 为什么ChCore能保证内核态线程的栈进入/退出内核时一定是空的？

