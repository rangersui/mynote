[toc]

# 进程

## 进程有哪些状态？为什么要定义这些状态？

- 新生状态（new）

  一个进程刚刚被创建，还没有完成初始化，不能被调度执行，完成初始化转移到就绪状态。

- 就绪状态（ready）

  进程可以被调度执行，还未被调度器选择。CPU数量少于进程数量，在某一时刻只能部分进程被调度到CPU上执行。此时，系统中其他可被调度的进程都处于就绪状态。在被调度器选择执行后，进程迁移至运行状态。

- 运行状态（running）

  正在CPU上运行，执行一段时间后，调度器可以选择中断它并重新将其放入调度队列，迁移至就绪状态。当程序运行结束，迁移至终止状态。如果一个进程需要等待某些外部状态，可以放弃CPU并迁移至阻塞状态。

- 阻塞状态（blocked）

  进程需要等待外部事件，暂时无法被调度。等待的外部事件完成后，迁移至就绪状态。

- 终止状态（terminated）

  进程已经完成了执行，不会再被调度。

## 进程的虚拟地址空间是什么样的结构？



## 进程是如何进行上下文切换的？



# Linux进程操作

## 为什么Linux要采取fork的方式创建进程？



## 为什么需要写时拷贝技术？



## fork和其他创建进程的方法相比有什么优点和缺点？



## 进程树是如何方便操作系统进行管理的？



# 线程

## 为什么需要引入线程？



## 拥有多个线程的进程的虚拟地址空间结构是什么样的？



## 用户态线程与内核态线程的区别和联系分别是什么？



## 针对线程的核心操作有哪些？



# 纤程

## 为什么对纤程的需求越来越强烈？



## 什么是纤程？如何使用纤程？



## 纤程如何进行上下文切换？



## 纤程与进程、线程的区别有哪些？



# 思考题

## 为什么不用类似于fork的方法创建线程呢？



## Linux中，一个多线程进程使用fork生成了一个新进程，新进程中会存在几个线程？为什么要这么设计?



## 编写至少两种使用fork的程序，使fork执行失败，解释fork失败的原因。



## 为什么ChCore能保证内核态线程的栈进入/退出内核时一定是空的？

