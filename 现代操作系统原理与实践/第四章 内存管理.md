[toc]

为了让不同应用程序能够既高效又安全地共同使用物理内存资源，现代操作系统加入了一个新的抽象：虚拟内存（virtual memory）。

应用程序面向虚拟内存编写，CPU将虚拟地址翻译成物理地址，操作系统负责虚拟地址和物理地址之间的映射。每个应用程序只能能看到自己的虚拟地址空间，从而保证不同应用程序所用内存之间的隔离。

虚拟内存设计有三个方面的目标：

- 高效性：虚拟内存不能在应用程序运行过程中造成明显性能开销；另外，虚拟内存抽象不应该占用过多物理内存资源
- 安全性：虚拟内存抽象需要使用不同应用程序的内存相互隔离，即一个应用程序只能访问属于自己的物理内存区域
- 透明性：虚拟内存抽象需要考虑到对应用程序的透明性，使得应用程序开发者在编程时无需考虑虚拟内存抽象

# 虚拟地址和物理地址

## 什么是物理地址和虚拟地址？

 物理内存中的每一个字节都存在对应的地址进行访问，这被称为物理地址。

应用程序使用虚拟地址访问存储在内存中的数据和代码。

## 什么是地址翻译？

虚拟地址通过MMU（内存管理单元）转换为物理地址的过程称为地址翻译。

## 地址翻译的主要机制有哪些？

地址翻译的主要机制有：

- **分段**机制

  操作系统以段（连续的物理内存）的形式管理/分配物理内存。应用程序的虚拟地址空间由若干个不同大小的段组成，如代码段，数据段。当CPU访问其中某个段的时候，MMU通过查询段表（含段起始地址和段长）得到该段对应的物理内存区域。

  - 段号

    标识虚拟地址属于整个虚拟地址空间的哪一段

  - 段内地址

    也称为段内偏移，相对于该段起始地址的偏移量

  翻译过程中，MMU通过段表基址寄存器找到段表位置，结合段号找到段表中对应段信息，取出该段起始地址（物理地址）加上虚拟地址内的段内地址（偏移）得到最终的物理地址。

  这种方式导致物理内存出现**外部碎片**即段与段之间留下碎片（不足以映射给虚拟地址空间的段）。就比如应用程序需要2G物理空间，但是如果物理内存不存在2GB的连续空间，那么就无法正常分配。

- **分页**机制

  这是目前广泛采用的机制。将应用程序的虚拟地址空间划分成连续的等长的虚拟页，同时物理内存也被划分为连续的等长的物理页。虚拟页和物理页的页长固定且相等，使得操作系统能为每个应用程序构造**页表**（虚拟页到物理页的映射关系表）。虚拟地址也有两部分组成：

  - 虚拟页号
  - 页内偏移量

  分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此操作系统也能实现物理内存资源的离散分配，易于管理且避免**外部碎片**。

# 基于分页的虚拟内存

## 为什么需要多级页表？

对于一个64位系统，假设每个页大小为4KB，页表中每个项大小为8字节（储存物理地址），那么页表大小为2\^64/4KB*8B，即33554432GB，为了压缩页表的大小，所以引入了多级结构的页表以满足虚拟内存在空间高效性方面的要求。

虚拟地址依然包括页号和页内偏移量，但是页号被划分为k个部分，任意一级某一条目为空时，该条目对应下一级及之后的页表都不存在。多级页表可以被部分创建，因此能够极大节约空间。

## AArch64体系结构下的多级页表是什么样的？

在AArch64体系结构下多级页表常见设置为：虚拟地址低48位参与地址翻译，页表级数为4级，虚拟页大小为4KB。

因为页大小为4KB，所以虚拟地址的低12位（2^12=4KB）对应页内偏移量。整个页表的起始地址存储在一个特殊的寄存器中，对于Linux在内的操作系统上用户地址空间来说，这个页表基地址寄存器是TTBR0_EL1。

第0级（顶级）页表有且只有一个页表页，页表基地址寄存器存储的就是该页的物理地址。其余每一级页表拥有若干个离散的页表页，每一个页表页占据物理内存中的一个物理页4KB。每个页表项占8B，用于储存物理地址和相应权限，因此一个页表中含有512个页表项，对应9位，因此虚拟地址中对应于每一级页表的索引都是9位。

> 若每一个页大小位8KB，4级页表，应该如何分配地址？
>
> 将低13位表示页内偏移量，每一级页表的索引占用10位。

## 为什么需要TLB，以及TLB的工作原理是什么？

### 为什么需要TLB

多级页表结构能显著压缩页表大小，但是会导致地址翻译时长增加，一次地址翻译导致多次物理内存访问。为了减少地址翻译访存次数，MMU引入地址旁路缓存（Translation Lookaside Buffer，TLB）部件来加速地址翻译过程。TLB缓存了虚拟页号到物理页号的映射关系。

### TLB工作原理

TLB在地址翻译过程中由MMU管理，当TLB发生未命中时，硬件通过页表基地址查询页表，找到对应的页表项，并将翻译结果填写到TLB；若TLB已满则根据硬件规定的策略替换某一项。之后翻译同样的虚拟页号硬件就能迅速从中找到对应的物理页号。

在TLB引入需要保证TLB中内容与当前页表内容的一致性，页表在切换时（应用程序切换）主动刷新TLB。若操作系统在切换程序的过程中刷新TLB，那么应用程序开始执行的时候总是会发生TLB未命中。

为了避免这一开销，提供了一种为TLB缓存打上“标签”的设计。在AArch64体系为例，提供了ASID (Address Space IDentifier) ，该功能对应x86-64上的PCID (Process Context IDentifier)。

具体来说操作系统可以为不同的应用程序分配不同ASID作为程序身份标签，再将这个标签写入应用程序的页表基地址寄存器的空闲位（如TTBR0_EL1的高16位）。同时TLB的缓存项也会包含ASID这个标签，从而使得TLB中属于不同应用程序的缓存项可以被区分开。因此在切换页表时，操作系统不需要清空TLB缓存项。

但是在修改页表内容后，操作系统还是需要主动刷新TLB以保证TLB缓存和页表内容一致，AArch64体系结构提供了多种不同颗粒度刷新TLB的指令。

## 什么是换页/缺页，以及为什么需要他们？

### 换页

虚拟内存中的换页机制就是为了透明地满足物理内存容量不足的需要所设计的。操作系统会在物理内存容量不足时把若干物理页写到类似于磁盘这种容量更大更便宜的储存设备中，然后就可以回收这些物理页并继续使用。

比如说操作系统希望从程序A回收物理页P，操作系统将物理页P的内容写到磁盘上的一个位置，并且在应用程序A的页表中去除虚拟页V的映射，同时记录该物理页被换到磁盘上的对应位置。该过程称为物理页P的换出（swap out），此时物理页P被操作系统回收分配给别的应用程序使用，虚拟页V处于已分配但未映射至物理内存的状态。

### 缺页异常

缺页异常与换页机制密不可分，也是换页机制工作的前提。应用程序访问**已分配但未映射至物理内存的虚拟页**（比如申请了足够大的虚拟内存，大部分虚拟页都是已分配但未映射）时，就会触发缺页异常。此时CPU会运行操作系统预先设置的缺页异常处理函数（page fault handler），该函数找到（或换页）一个空闲的物理页，将写到磁盘上的数据重新加载到该物理页中，并且在页表中填写虚拟地址到这以物理页的映射。该过程称为换入（swap in）。

>  由于换页过程中涉及磁盘操作，操作系统往往会引入预取（prefetching）机制进行优化。当发生换入操作时，预测还有哪些页即将被访问，提前将他们一并换入物理内存，减少发生缺页异常的次数。

## 如何选择页进行替换：页替换策略有哪些？

- MIN/OPT
- FIFO
- Second Chance
- LRU
- MRU
- 时钟算法

## 工作集模型



# 虚拟内存功能

## 如何利用虚拟内存实现内存共享？



## 什么是写时拷贝（copy-on-write）？写时拷贝是如何实现的？



## 如何利用虚拟内存抽象节约物理内存（内存去重和内存压缩）？



## 什么是大页，以及为什么需要使用大页？



# 物理内存分配与管理

## 如何评价物理内存分配器的优劣？



## 广泛使用的伙伴系统分配器的工作原理是什么？



## 为什么有伙伴系统分配器还需要SLAB分配器，以及SLAB分配器的工作原理是什么？



## 分配器中会使用到的关键数据结构——空闲链表是什么样的？



## 除了分配物理内存资源外，操作系统还需要管理CPU缓存资源吗？



