[toc]

为了让不同应用程序能够既高效又安全地共同使用物理内存资源，现代操作系统加入了一个新的抽象：虚拟内存（virtual memory）。

应用程序面向虚拟内存编写，CPU将虚拟地址翻译成物理地址，操作系统负责虚拟地址和物理地址之间的映射。每个应用程序只能能看到自己的虚拟地址空间，从而保证不同应用程序所用内存之间的隔离。

虚拟内存设计有三个方面的目标：

- 高效性：虚拟内存不能在应用程序运行过程中造成明显性能开销；另外，虚拟内存抽象不应该占用过多物理内存资源
- 安全性：虚拟内存抽象需要使用不同应用程序的内存相互隔离，即一个应用程序只能访问属于自己的物理内存区域
- 透明性：虚拟内存抽象需要考虑到对应用程序的透明性，使得应用程序开发者在编程时无需考虑虚拟内存抽象

# 虚拟地址和物理地址

## 什么是物理地址和虚拟地址？

 物理内存中的每一个字节都存在对应的地址进行访问，这被称为物理地址。

应用程序使用虚拟地址访问存储在内存中的数据和代码。

## 什么是地址翻译？

虚拟地址通过MMU（内存管理单元）转换为物理地址的过程称为地址翻译。

## 地址翻译的主要机制有哪些？

地址翻译的主要机制有：

- **分段**机制

  操作系统以段（连续的物理内存）的形式管理/分配物理内存。应用程序的虚拟地址空间由若干个不同大小的段组成，如代码段，数据段。当CPU访问其中某个段的时候，MMU通过查询段表（含段起始地址和段长）得到该段对应的物理内存区域。

  - 段号

    标识虚拟地址属于整个虚拟地址空间的哪一段

  - 段内地址

    也称为段内偏移，相对于该段起始地址的偏移量

  翻译过程中，MMU通过段表基址寄存器找到段表位置，结合段号找到段表中对应段信息，取出该段起始地址（物理地址）加上虚拟地址内的段内地址（偏移）得到最终的物理地址。

  这种方式导致物理内存出现**外部碎片**即段与段之间留下碎片（不足以映射给虚拟地址空间的段）。就比如应用程序需要2G物理空间，但是如果物理内存不存在2GB的连续空间，那么就无法正常分配。

- **分页**机制

  这是目前广泛采用的机制。将应用程序的虚拟地址空间划分成连续的等长的虚拟页，同时物理内存也被划分为连续的等长的物理页。虚拟页和物理页的页长固定且相等，使得操作系统能为每个应用程序构造**页表**（虚拟页到物理页的映射关系表）。虚拟地址也有两部分组成：

  - 虚拟页号
  - 页内偏移量

  分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此操作系统也能实现物理内存资源的离散分配，易于管理且避免**外部碎片**。

# 基于分页的虚拟内存

## 为什么需要多级页表？



## AArch64体系结构下的多级页表是什么样的？



## 为什么需要TLB，以及TLB的工作原理是什么？



## 什么是换页/缺页，以及为什么需要他们？



## 如何选择页进行替换：页替换策略有哪些？



# 虚拟内存功能

## 如何利用虚拟内存实现内存共享？



## 什么是写时拷贝（copy-on-write）？写时拷贝是如何实现的？



## 如何利用虚拟内存抽象节约物理内存（内存去重和内存压缩）？



## 什么是大页，以及为什么需要使用大页？



# 物理内存分配与管理

## 如何评价物理内存分配器的优劣？



## 广泛使用的伙伴系统分配器的工作原理是什么？



## 为什么有伙伴系统分配器还需要SLAB分配器，以及SLAB分配器的工作原理是什么？



## 分配器中会使用到的关键数据结构——空闲链表是什么样的？



## 除了分配物理内存资源外，操作系统还需要管理CPU缓存资源吗？



